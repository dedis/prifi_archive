#!/usr/bin/env python
'''
Created on Jun 25, 2014

@author: eleanor
'''
import random
import string
import math
import unittest
from bitstring import Bits, BitArray
from Crypto.Util.number import long_to_bytes, bytes_to_long
from Crypto.Hash import SHA256

cell_bit_length = 24 * 8  # Bits per cell
chunk_size = 24  # bits per chunk
# number of chunks of data that can fit in a cell
chunks_per_cell = math.floor((cell_bit_length) / +\
                             (1 + 1 / chunk_size + chunk_size))
# number of bytes needed to represent the inversion bits
invert_header_size = math.ceil(math.ceil(chunks_per_cell / (chunk_size - 1)) * \
                               chunk_size / 8)
# number of chunks needed to represent the inversion bits
invert_header_chunks = math.ceil(invert_header_size * 8 / chunk_size)
# maximum number of bytes of data that encode can be called on
max_in_size = chunks_per_cell * chunk_size // 8

class InversionBase():
    """ Base class for classes that need to know the trap noise and positions.

    The multiple random number generators are handled with the attributes
    noise_states and position_state, which are used and updated each time bits
    from that random number generator are needed.
    """

    def __init__(self, seeds):
        """ seeds is the list of trap secrets for this slot owner (one per
        trustee) """
        self.noise_states = []
        h = SHA256.new()
        for seed in seeds:
            h.update(long_to_bytes(seed))
            random.seed(seed)
            self.noise_states.append(random.getstate())
        random.seed(h.digest())
        self.position_state = random.getstate()

    def trap_noise(self, count):
        """ Generate count terms of the noise sequence. This is the xor of the
        next bits of the random sequence generated by each trustee-owner shared
        secret.
          inputs:
            count: Number of cells of unit to generate
          outputs:
            noise (Bits list): List of noise cells
        """
        noises = {}
        noise = [Bits(cell_bit_length)] * count
        for i in range(len(self.noise_states)):
            noises[i] = []
            random.setstate(self.noise_states[i])
            for celldx in range(count):
                noises[i].append(random.getrandbits(cell_bit_length))
                noise[celldx] ^= Bits(uint=noises[i][-1], length=cell_bit_length)
            self.noise_states[i] = random.getstate()
        noise = [n.tobytes() for n in noise]
        return noise

    def trap_positions(self, num_chunks):
        """ Generate num_chunks terms of the trap position sequence.
          outputs:
            positions (int list): List of trap bit positions (ints between 0 and
              chunk_size)
          """
        random.setstate(self.position_state)
        positions = [random.randint(0, chunk_size - 1)\
                     for _ in range(num_chunks)]
        self.position_state = random.getstate()
        return positions

class InversionChecker(InversionBase):
    def check(self, cell):
        """ Checks that the trap bit in each chunk in cell is correct.
            Precondition: noise_state and position_state should be in the
            initial state for the cell to be checked.

          inputs:
            cell (Bits list): The chunks output of encode
            output: True if it all matches, False otherwise.
        """
        cell = Bits(uint=bytes_to_long(cell), length=cell_bit_length)
        if (len(cell) < 1):
            print("Warning: Attempt to check empty ciphertext")
            return True
        [noise] = self.trap_noise(1)
        positions = self.trap_positions(invert_header_chunks + chunks_per_cell)
        # get a mask that's 0 for non trap bits and the trap bit for trap bits.
        pos_mask = BitArray().join(
            [Bits([False] * (chunk_size - 1) + [True]) << (chunk_size - pos - 1) \
             for pos in positions])
        mask = pos_mask & noise
        return mask & cell == mask

class InversionEncoder(InversionBase):
    """ Class for encoding cells according to the inversion scheme.

    NOTE: This currently only supports encoding cells with sizes that are
    multiples of the chunk size.
    """
    def encode(self, cell):
        """ Takes plaintext to encode and returns a list of bytes encoding it.
        An n-bit input_text with chunks size k, the total
        important output data produced will take up n + (n/k) bits because the
        header adds (n/k) bits of overhead.

        inputs:
          cell (bytes): The data to encode
        """
        assert self.encoded_size(len(cell)) <= cell_bit_length // 8, \
               "encoded size for {0} byte cell is {1} but only {2} will fit" \
               .format(len(cell), self.encoded_size(len(cell)), max_in_size)
        chunks = bits_to_chunks(Bits(cell), padchunks=True, padcell=True)
        assert(len(chunks) >= 1)
        [noise] = self.trap_noise(1)
        positions = self.trap_positions(len(chunks) + invert_header_chunks)
        header_chunks, enc = self.__encode_chunks(bits_to_chunks(Bits(noise)),
                                                  positions, chunks)
        header = BitArray().join(header_chunks)
        inv_h = Bits(header + [False] * \
                              math.ceil(invert_header_size * 8 - len(header)))
        joined = inv_h.tobytes() + BitArray().join(enc).tobytes()
        return (noise ^ Bits(joined)).tobytes()

    def decoded_size(self, size):
        """ The size in bytes of the decoded version of an encoded string that
        is size bytes long
        Note: We can't tell exactly the decoded size without looking at the
        length field, so this returns a max size that will be within one
        chunk_size of the actual answer.
        """
        return max_in_size

    def encoded_size(self, size):
        """ The size in bytes of the encoded version of a decoded string that
        is size bytes long """
        chunks = math.ceil(8 * size / chunk_size)
        if chunks < chunks_per_cell:
            chunks = chunks_per_cell
        return math.ceil(chunks * chunk_size / 8) + \
            invert_header_size * (chunks - chunks_per_cell + 1)

    def __encode_chunks(self, noise, positions, chunks):
        """ Encodes a list of Bits objects.

          inputs:
            noise (Bits list): The list of noise chunks to encode around
            positions (int list): The position of the trap bit in each chunk
            chunks (Bits list): The output of bits_to_chunks, to be encoded
          outputs:
            header_chunks (Bits list): Bits indicating whether each chunk of
              new_chunks is inverted or not. This field is also encoded into
              chunks, where the first bit of each chunk indicates whether it is
              inverted.
            new_chunks (Bits list): List of the encoded chunks, represented as
              Bits
        """
        new_chunks = []
        new_header = []
        header_noise = noise[:invert_header_chunks]
        noise = noise[invert_header_chunks:]
        header_positions = positions[:invert_header_chunks]
        positions = positions[invert_header_chunks:]
        assert(len(chunks) == len(positions) == len(noise)), \
            "Lengths mismatch: Chunks: {0} Positions: {1} noise: {2}" \
            .format(len(chunks), len(positions), len(noise))
        for i in range(len(chunks)):
            if chunks[i][positions[i]] == noise[i][positions[i]]:
                new_chunks += [chunks[i]]
                new_header += [False]
            else:
                new_chunks += [~chunks[i]]
                new_header += [True]
        header_chunks = bits_to_chunks(new_header, padchunks=True, prepend=1)
        for i in range(len(header_noise)):
            if header_chunks[i][header_positions[i]] != \
              header_noise[i][header_positions[i]]:
                header_chunks[i] = ~header_chunks[i]
        return header_chunks, new_chunks

class InversionDecoder:
    def decode(self, cell):
        """ Takes the output of encode and returns it decoded (in bytes).
        """
        cipherheader, cipherchunks = self.__encoded_bytes_to_header_chunks(cell)
        plain_chunks = self.__decode_chunks(cipherheader, cipherchunks)
        joined = BitArray().join(plain_chunks)
        return joined.tobytes()

    def __decode_chunks(self, head, chunks):
        """ Takes encoded input and returns the decoded chunks
        inputs:
          head (Bits): The inversion bits as a single bit list. Must be the
            same length as chunks (trailing bits will be ignored)
          chunks (Bits list): The data chunks, excluding the length field added
            in encode
        """
        plain_chunks = []
        for i in range(len(chunks)):
            invert = head[i]
            decoded = chunks[i]
            if invert:
                decoded = ~decoded
            plain_chunks += [decoded]
        return plain_chunks

    def __encoded_bytes_to_header_chunks(self, cell):
        """ Converts an encoded list of bytes to a tuple (header, chunks),
        header is the inversion bits, and chunks is a list of chunks of data.
        """
        # Separate the inversion bits
        header_chunks = \
            bits_to_chunks(Bits(cell)[:invert_header_chunks * chunk_size])
        offset = invert_header_size
        # Decode the inversion bits
        header_decoded_chunks = []
        for i in range(len(header_chunks)):
            # Remove the prepended bits from encode
            header_decoded_chunks.append(header_chunks[i][1:])
            if header_chunks[i][0] == 1:
                # Flip chunks of inversion bits if needed
                header_decoded_chunks[-1] = ~header_decoded_chunks[-1]
        # De-chunk so the inversion bits are a single bitstring
        header = BitArray().join(header_decoded_chunks)
        cipherchunks = bits_to_chunks(Bits(cell[offset:]))
        cipherheader = Bits(header[:len(cipherchunks)])
        return cipherheader, cipherchunks

###### Shared helper functions ######

def bits_to_chunks(in_bin, padcell=False, padchunks=False, prepend=0):
    """ in_bin (Bits): the input message
        padcell (bool): If True, blank chunks will be added so the output fills
          a cell (with room left for inversion bits)
        padchunks (bool): If True, if the last chunk is less than chunk_size,
          zeros will be appended until it fills a chunk
        prepend (int): The number of bits to be prepended to each chunk. If this
          is set to greater than zero, then chunk_size - prepend bits of data
          and prepend zero-bits at the beginning will be in each output chunk.
          This is used for the alternate encoding scheme used for the inversion
          header.
    """
    new_chunks = [Bits([False] * prepend + in_bin[i:i + chunk_size - prepend])\
            for i in range(0, len(in_bin), chunk_size - prepend)]
    if padchunks:
        new_chunks[-1] = Bits(new_chunks[-1] + \
                          [False] * (chunk_size - len(new_chunks[-1])))
    if padcell:
        extra_chunks = chunks_per_cell - len(new_chunks)
        new_chunks.extend([Bits([False] * chunk_size)] * extra_chunks)
    return new_chunks

###### Tests ######

class Test(unittest.TestCase):
    def setUp(self):
        self.c = InversionChecker([1, 2])
        self.decode_helper = InversionBase([1, 2])
        self.e = InversionEncoder([1, 2])
        self.d = InversionDecoder()

    def test_correctness(self):
        for i in range(10):
            random.seed()
            to_test = self.rand_string(random.randint(1, max_in_size))
            self.encode_check_decode(to_test)
        print("[+] Passed correctness")

    def encode_check_decode(self, message="", msg_b=None):
        if msg_b == None:
            msg_b = bytes(message, "utf-8")
        size = len(msg_b)
        encoded = Bits(self.e.encode(msg_b))
        noise = Bits(self.decode_helper.trap_noise(1)[0])
        to_decode = encoded ^ noise
        new_text_b = self.d.decode(to_decode.tobytes())
        self.assertEqual(new_text_b[:size], msg_b,
                         msg="[x] Failed decoding:\n Expected {0}\n but got {1}"
                              .format(msg_b, new_text_b))
        self.assertTrue(self.c.check(to_decode.tobytes()),
                        msg="[x] Failed checking: Problem with trap bits for {0}"
                        .format(msg_b))
        self.size_reporting(encoded.tobytes(), msg_b)
        print("[+] Passed encode/check/decode for {0}".format(msg_b))

    def size_reporting(self, encoded, decoded):
        self.assertEqual(self.e.encoded_size(len(decoded)), len(encoded),
            msg="[x] Failed encoded size for {2}:\n Expected {0}, got {1}"
                  .format(len(encoded),
                          self.e.encoded_size(len(decoded)), decoded))
        self.assertGreaterEqual(self.e.decoded_size(len(encoded)), len(decoded),
            msg="[x] Failed decoded size for {2}:\n Expected {0}, got {1}"
                  .format(len(decoded),
                          self.e.decoded_size(len(encoded)), decoded))

    def rand_string(self, length=5):
        chars = list(string.ascii_uppercase + string.digits)
        ret = []
        for _ in range(length):
            ret += [random.choice(chars)]
        return ''.join(ret)

if __name__ == '__main__':
    unittest.main()
